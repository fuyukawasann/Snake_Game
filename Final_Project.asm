; 1-down, 4-left, 6-right, 9-up
; R0 - SNACK COL
; R1 - SNACK ROW
; R2 - FEED COL
; R3 - FEED ROW
; SET INITIAL POINT TO (1,4). INTIAL DIRECTION TO GO : RIGHT

; LCD -> TIME 7-SEG -> INTEGER

	ORIGIN	8000
;==========
; DOT MATRIX
COLGREEN	EQU	0FFC5H
COLRED		EQU	0FFC6H
ROW		EQU	0FFC7H
;==========

;==========
; DATA INPUT/OUTPUT INTERFACE
DATAOUT		EQU	0FFF0H
DATAIN		EQU	0FFF1H
;==========

;==========
; FUNCTION KEY
RWKEY	EQU	10H	; READ AND WRITE KEY
COMMA	EQU	11H	; COMMA(,)
PERIOD	EQU	12H	; PERIOD(.)
GO	EQU	13H	; GO-KEY
REG	EQU	14H	; REGISTER KEY
CD	EQU	15H	; DECREASE KEY
INCR	EQU	16H	; INCREASE KEY
ST	EQU	17H	; SINGLE STEP KEY
RST	EQU	18H	; RST KEY
;==========

;==========
; LCD
LCDWIR	EQU	0FFE0H ; WRITE LCD IR
LCDWDR	EQU	0FFE1H ; WRITE LCD DR
LCDRIR	EQU	0FFE2H ; READ LCD IR
LCDRDR	EQU	0FFE3H ; READ LCD DR

INST	EQU	20H ; SAVE LCD INSTRUCTION VALUE
DATA	EQU	21H ; SAVE LCD DATA VALUE
LROW	EQU	22H ; LCD COORDINATES(ROW VALUE)
LCOL	EQU	23H ; LCD COORDINATES(COLUMN VALUE)
NUMFONT	EQU	24H ; SAVE NUMBER OF MESSAGES
FDPL	EQU	25H ; SAVE DPL VALUE
FDPH	EQU	26H ; SAVE DPH VALUE

CLEAR		EQU	27H ; ORDERING CLEAR
CUR_HOME	EQU	28H ; SET CURSOR TO HOME
ENTRY2		EQU	29H ; CONTROL CURSOR'S DIRECTION AND MOVEMENT

DCB6	EQU	2AH ; DISP(ON), CUR(ON), BLINK(OFF)
FUN5	EQU	2BH ; FUNC. SETTING(8BIT 2ROW, 5*7, 1/16 DUTY)

LINE_1	EQU	80H ; 1000 0000 : MOVE TO LCD'S 1ST ROW
LINE_2	EQU	0C0H ; 1100 0000 : MOVE TO LCD'S 2ND ROW
;==========

;==========
; LCD SAVE
BPOR	EQU		2CH ; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R0)
BPOR2	EQU		2DH ; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R2)
BPOR3	EQU		2EH ; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R5 @DISFONT)
;==========

;==========
; KEY SAVE
VBUF	EQU		40H	; TEMPORARY STORAGE
CKST	EQU		41H ; CHECK USER PRESS ANY KEY BEGIN START
BPOV	EQU		42H ; BACK-UP FOR ORIGINAL VALUE OF REGISTER
;==========

;==========
; DELAY SAVE
DS1		EQU		4AH ; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R0)
DS2		EQU		4BH	; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R1)
DS3		EQU		4CH	; BACK-UP FOR ORIGINAL VALUE OF REGISTER(R2)
;==========

;==========
; DIRECT SAVE
DIRECT1	EQU		4DH ; SAVE DIRECTION INFO
;==========

; BEFORE STARTING GAME
; INITIALIZING LCD
RUNNING:	MOV		CKST, #1	; CHECKER FOR START
			MOV		BPOV, R3	; BACKUP R3 VALUE TO BPOV
			MOV		R3, CKST	; SET R3 TO CKST VALUE(#1)

LCD_INIT: 	MOV		INST, #FUN5 ; SET LCD INSTRUCTION TO FUNCTION SETTING
			CALL	INSTWR		; CALL SUBROUTINE, INSTWR

			MOV		INST, #DCB6 ; SET LCD INSTRUCTION TO DCB6
			CALL	INSTWR		; CALL SUBROUTINE, INSTWR

			MOV		INST, #CLEAR ; SET LCD INSTRUCTION TO CLEAR
			CALL 	INSTWR		; CALL SUBROUTINE, INSTWR

			MOV		INST, #ENTRY2 ; SET LCD INSTRUCTION TO ENTRY2
			CALL	INSTWR		; CALL SUBROUTINE, INSTWR

			MOV		BPOR, R0	; BACKUP R0 VALUE TO BPOR
			MOV		R0, #2		; SET R0 TO IMMEDIATE 2
			JMP		START		; JUMP TO START

DEC_R0:		DEC		R0			; PROCEED [R0]-1
			MOV		A, R0		; SET A TO [R0]
			INC		A			; INCREMENT OF A
			JZ		REFILL_R0	; IF A = 0 -> JUMP TO REFILL_R0

START:		MOV		A, R6		; SET A TO [R6]
			MOV		BPOR2, R2	; BACKUP R2 VALUE TO BPOR2
			MOV		R2, A		; SET R2 TO [A]
			MOV		LROW, #01H	; SET LROW TO IMMEDIATE 01H
			MOV		LCOL, R2	; SET LCOL TO [R2]
			CALL	CUR_MOV		; CALL SUBROUTINE CUR_MOV

			MOV		DPTR, #MESSAGE1	; SET DPTR TO MESSAGE1
			MOV		FDPL, DPL 	; SET FDPL TO DPTR'S LOW BIT
			MOV		FDPH, DPH 	; SET FDPH TO DPTR'S HIGH BIT
			MOV		NUMFONT, #0DH ; WE HAVE 13 FONTS -> SET NUMFONT TO 13
			CALL	DISFONT		; CALL SUBROUTINE DISFONT
			MOV		R5, BPOR3	; BACK R5'S ORIGINAL VALUES

			MOV		LROW, #02H	; SET LROW TO IMMEDIATE 02H
			MOV		LCOL, R2	; SET LCOL TO [R2]
			CALL	CUR_MOV 	; CALL SUBROUTINE CUR_MOV

			MOV		DPTR, #MESSAGE2 ; SET DPTR TO MESSAGE2
			MOV		FDPL, DPL	; SET FDPL TO DPTR'S LOW BIT
			MOV		FDPH, DPH	; SET FDPH TO DPTR'S HIGH BIT
			MOV		NUMFONT, #0DH ; 13 FONTS -> SET NUMFONT TO IMMEDIATE 0DH
			CALL	DISFONT		; CALL SUBROUTINE DISFONT
			MOV		R5, BPOR3	; BACK R5'S ORIGINAL VALUES
			CALL	DELAY_OFF	; CALL SUBROUTINE DISFONT

			MOV		INST, #CLEAR	; SET INST TO CLEAR
			CALL	INSTWR		; CALL SUBROUTINE INSTWR
			
			CALL	FINDKEYCODE ; CALL ROUTINE THAT READ KEYCODE
			MOV		VBUF, A 	; SAVE KEYCODE IN VBUF
			
			CJNE	A, #00H, GOTONEXT	; DIDN'T PRESS ->
			JMP		GOOVER		; JUMP TO GOOVER		
GOTONEXT:	DEC		R3			; SET R3 TO 0 [ 1-1 = 0 ]
GOOVER:		CJNE	R3,#0,DEC_R0 ; IF ANY KEYS DIDN'T PRESS -> RETURN TO DEC_R0(LOOP)	
			JMP		MAIN
			
REFILL_R0:	MOV		R0, #20		; SET R0 TO IMMEDIATE 20	
			JMP		DEC_R0		; AFTER REFILL, GO BACK TO DEC_R0



; GAME START
MAIN:		



;==========
; SUBROUTINE : DIRECT
; FUNC : SELECT DIRECTION
;==========
DIRECT:		MOV		INST, #CLEAR	; SET INST TO CLEAR
			CALL	INSTWR		; CALL SUBROUTINE INSTWR
			
			CALL	FINDKEYCODE ; CALL ROUTINE THAT READ KEYCODE
			MOV		VBUF, A 	; SAVE KEYCODE IN VBUF

SEL4:		CJNE	A,#04H,SEL1	; IF I PRESS 4 -> CHANGE DIRECTION TO LEFT || IF NOT -> GO TO SEL1
			MOV		DIRECT1, #01 ; 01 -> LEFT
			RET

SEL1:		CJNE	A,#01H,SEL6	; IF PRESSED KEY IS 1 -> CHANGE DIRECTION TO DOWN || IF NOT -> GO TO SEL6
			MOV		DIRECT1, #00 ; 00 -> DOWN
			RET

SEL6:		CJNE	A,#06H,SEL9	; IF PRESSED KEY IS 6 -> CHANGE DIRECTION TO RIGHT || IF NOT -> GO TO SEL9
			MOV		DIRECT1, #10 ; 10 -> RIGHT
			RET

SEL9:		CJNE	A,#09H,NOSEL ; IF PRESSED KEY IS 9 -> CHANGE DIRECTION TO UP || IF NOT -> GO TO NOSEL
			MOV		DIRECT1, #11 ; 11 -> UP
			RET

NOSEL:		RET


;==========
; SUBROUTINE : MOVER
; FUNCTION : REAL MOVER
;==========
MOVER:		PUSH	A	; BACK-UP ACC
			MOV		A, DIRECT1	; 00 -> DOWN, 10 -> LEFT, 01 -> RIGHT, 11 -> UP

D_MOVE:		CJNE	A,#00,U_MOVE	; A == 00 -> DOWN MOVE != -> JUMP TO U_MOVE
			MOV		A, SNAKEROW		; A = [ SNAKEROW ]
			CLR		A				; CLEAR CARRY
			RLC		A				; ROTATE LEFT OF SNAKEROW
			JC		GAME_OVER		; IF CARRY == 1 -> JUMP TO GAME_OVER
			MOV		SNAKEROW, A		; SAVE SNAKE_ROW DATA TO SNAKEROW
			POP		A				; BACK A'S ORIGINAL VALUE
			RET						; RETURN TO ORIGINAL ROUTINE
U_MOVE:		CJNE	A,#11,L_MOVE	; A == 11 -> UP MOVE != -> JUMP TO L_MOVE
			MOV		A, SNAKEROW		; A = [ SNAKEROW ]
			CLR		A				; CLEAR CARRY
			RRC		A				; ROTATE RIGHT OF SNAKEROW
			JC		GAME_OVER		; IF CARRY == 1 -> JUMP TO GAME_OVER
			MOV		SNAKEROW, A		; SAVE SNAKE_ROW DATA TO SNAKEROW
			POP		A				; BACK A'S ORIGINAL VALUE
			RET						; RETURN TO ORIGINAL ROUTINE
L_MOVE:		CJNE	A,#10,R_MOVE	; A == 10 -> LEFT	MOVE != -> JUMP TO R_MOVE
			MOV		A, SNAKECOL		; A = [ SNAKECOL ]
			CLR		A				; CLEAR CARRY
			RRC		A				; ROTATE RIGHT OF SNAKECOL
			JC		GAME_OVER		; IF CARRY == 1 -> JUMP TO GAME_OVER
			MOV		SNAKECOL, A		; SAVE SNAKE_COL DATA TO SNAKECOL
			POP		A				; BACK A'S ORIGINAL VALUE
			RET						; RETURN TO ORIGINAL ROUTINE
R_MOVE:		MOV		A, SNAKECOL		; A = [ SNAKECOL ]
			CLR		A				; CLEAR CARRY
			RLC		A				; ROTATE LEFT OF SNAKECOL
			JC		GAME_OVER		; IF CARRY == 1 -> JUMP TO GAME_OVER
			MOV		SNAKECOL, A		; SAVE SNAKE_COL DATA TO SNAKECOL
			POP		A				; BACK A'S ORIGINAL VALUE
			RET						; RETURN TO ORIGINAL ROUTINE


;==========
; SUBROUTINE : DELAY_OFF
; FUNC : MAKE DELAY
;==========
DELAY_OFF:	MOV		DS1, R0 ; BACK-UP R0 TO DS1
			MOV 	DS2, R1 ; BACK-UP R1 TO DS2
			MOV 	DS3, R2 ; BACK-UP R2 TO DS3
			MOV		R0, #0FFH ; SET R0 TO IMMEDIATE 0FFH
DELAY_OFF1: MOV		R1, #0AFH ; SET R1 TO IMMEDIATE 0AFH
DELAY_OFF2: MOV		R2, #02FH ; SET R2 TO IMMEDIATE 02FH
DELAY_OFF3: DJNZ	R2, DELAY_OFF3	; BEFORE R2 EQUALS 0 -> JUMP TO DELAY_OFF3
			DJNZ	R1, DELAY_OFF2 	; BEFORE R1 EQUALS 0 -> JUMP TO DELAY_OFF2
			DJNZ	R0, DLEAY_OFF1	; BEFORE R0 EQUALS 0 -> JUMP TO DELAY_OFF1
			MOV		R2, DS3	; BACK R2'S ORIGINAL VALUE
			MOV		R1, DS2 ; BACK R1'S ORIGINAL VALUE
			MOV		R0, DS1 ; BACK R0'S ORIGINAL VALUE
			RET				; RETURN TO ORIGINAL ROUTINE


;==========
; SUBROUTINE : CUR_MOV
; INPUT : LROW, LCOL
; OUTPUT : LCD DISPLAY
; FUNCTION : SET CURSORS COORDINATES
;==========
CUR_MOV:	MOV		A, LROW		; SET A TO [LROW]
			CJNE	A, #01H, NEXT ; IF A DOESN'T EQUAL 01H -> JUMP TO NEXT
			MOV		A, #LINE_1 	; SET A TO [LINE_1]
			ADD 	A, LCOL 	; A + LCOL
			MOV 	INST, A		; SET INST TO [A]
			CALL	INSTWR		; CALL SUBROUTINE, INSTWR
			JMP		RET_POINT	; JUMP TO RET_POINT
NEXT:		CJNE	A, #02H, RET_POINT	; IF A DOESN'T EQUAL 02H -> JUMP TO RET_POINT
			MOV		A, #LINE_2	; SET A TO [LINE_2]
			ADD		A, LCOL		; A + LCOL
			MOV		INST, A 	; SET INST TO [A]
			CALL	INSTWR		; CALL SUBROUTINE INSTWR
RET_POINT:	RET					; RETURN TO ORIGINAL ROUTINE


;==========
; SUBROUTINE : DISFONT
; INPUT : ---
; OUTPUT : LCD DISPLAY
; FUNC : READ FONTS AND DISPLAY
;==========
DISFONT:	MOV		BPOR3, R5	; BACKUP R5 TO BPOR3
			MOV		R5, #00H	; SET R5 TO 00H
FLOOP3:		MOV		A, R2		; SET A TO R2(LCOL)
			ADD		A, R5		; A + [R5]
			CJNE	A, #20, FLOOP	; IF A DOENS'T EQUALS 20 -> JUMP TO FLOOP (OVER LCD DISPLAY)
			MOV		LCOL, #00H	; SET LCOL TO 00H
			CALL	CUR_MOV		; CALL SUBROUTINE CUR_MOV
FLOOP2:		MOV		DPL, FDPL	; SET DPL TO FDPL
			MOV		DPH, FDPH	; SET DPH TO FDPH
			MOV		A, R5		; SET A TO [R5]
			MOVC	A, @A+DPTR	; SET A TO @A+DPTR(VALUE LOCATE AT A+DPTR)
			MOV		DATA, A		; SET DATA TO [A]
			CALL	DATAWR		; CALL SUBROUTINE DATAWR
			INC		R5			; INCREMENT OF [R5]
			MOV		A, R5		; SET A TO [R5]
			CJNE	A, NUMFONT, FLOOP2	; IF A DOESN'T EQUAL NUMFONT -> JUMP TO FLOOP2
			RET					; RETURN TO ORIGINAL ROUTINE
FLOOP:		MOV		DPL, FDPL	; SET DPL TO [FDPL]
			MOV		DPH, FDPH	; SET DPH TO [FDPH]
			MOV		A, R5		; SET A TO [R5]
			MOVC	A, @A+DPTR	; SET A TO @A+DPTR(VALUE LOCATE AT A+DPTR)
			MOV		DATA, A		; SET DATA TO [A]

			CALL	DATAWR		; CALL SUBROUTINE DATAWR
			INC		R5			; INCREMENT OF [R5]
			MOV		A, R5		; SET A TO [R5]
			CJNE	A, NUMFONT, FLOOP3	; IF A DOESN'T EQUAL NUMFONT -> JUMP TO FLOOP3
			RET					; RETURN TO ORIGINAL ROUTINE

;==========
; SUBROUTINE : INSTWR
; INPUT : INST
; OUTPUT : LCD DISPLAY
; FUNC : WRITE INST TO LCD INSTRUCTION REGISTER
;==========
INSTWR:		CALL	INSTRD		; CALL SUBROUTINE INSTRD
			MOV		DPTR, #LCDWIR	; SET DPTR TO LCDWIR
			MOV		A, INST	; SET A TO INST
			MOVX	DPTR, @A	; MOV A TO @DPTR(ADDRESS POINTED BY DPTR)
			RET					; RETURN TO ORIGINCAL ROUTINE


;==========
; SUBROUTINE : DATAWR
; INPUT : DATA
; OUTPUT : LCD DISPLAY
; FUNC : WRITE DATA TO LCD DATA REGISTER
;==========
DATAWR:		CALL	INSTRD		; CALL SUBROUTINE INSTRD
			MOV		DPTR, #LCDWDR	; SET DPTR TO [LCDWDR]
			MOV		A, DATA		; SET A TO [DATA]
			MOVX	@DPTR, A	; MOV A TO @DPTR(ADDRESS POINTED BY DPTR)
			RET					; RETURN TO ORIGINAL ROUTINE

;==========
; SUBROUTINE : INSTRD
; INPUT : ---
; OUTPUT : BUSY
; FUNC : READ BUSY FLAG/ADDRESS
;==========
INSTRD:		MOV		DPTR, #LCDRIR	; SET DPTR TO [LCDRIR]
			MOVX	A, @DPTR		; MOV A TO @DPTR(ADDRESS POINTED BY DPTR)
			JB		ACC.7, INSTRD	; IF ACC.7 IS 1 -> JUMP TO INSTRD(1 MEANS WE CAN USE LCD DISPLAY)
			RET						; RETURN TO ORIGINAL ROUTINE

;==========
; DEFINE MESSAGE
;==========
; MESSAGE 1, 2 -> BEGIN TO START GAME
MESSAGE1:	DB	'P','r','e','s','s'
			DB	' ','A','n','y',' '
			DB	'K','e','y'

MESSAGE2:	DB	't','o',' ','S','t'
			DB	'a','r','t',' ',' '
			DB	' ',' ',' '
; MESSAGE3 -> PAUSE GAME
MESSAGE3:	DB	'P',' ','A',' ','U'
			DB	'S',' ','E'
; MESSAGE4 -> END OF GAME
MESSAGE4:	DB	'G','a','m','e',' '
			DB	'O','v','e','r'
; NUM -> WHEN DISPLAY TIMER
NUM:		DB	'0','1','2','3','4'
			DB	'5','6','7','8','9'



;==========
; SUBROUTINE : FINDKEYCODE
; INPUT : A
; OUTPUT : A
; FUNC : FIND CORRECT KEY CODE
;==========
FINDKEYCODE:	PUSH	PSW ; STORE PSW VALUE AT STACK
		SETB	PSW.4	; USING BANK-3 REG
		SETB	PSW.3

INITIAL:	MOV	R4, #00H ; INTIALIZING R4 == USING R4 TO KEY VALUE
		MOV	A, #11101111B; INITIAL VALUE OF DATAOUT
		SETB	C

COLSCAN:	MOV	R5, A	; STORE DATA_OUT AT R5
		INC	R4	; SAVING R4'S ROW VALUE
		CALL 	SUBKEY	; SEARCHING KEY PAD INPUT
		
		CJNE	A,#0FFH,RSCAN ; IF A DOES NOT EQUL AS #0FFH -> KEY INPUT OCCURS
		
		MOV	A, R5
		SETB	C
		RRC	A	; MOVE NEXT COLUMN
		JNC	INITIAL ; IF SCANNING ALL COLUMNS -> RESTART
		JMP	COLSCAN	; BRANCH FOR SCANNING NEXT COLUMN

RSCAN:		MOV	R6, #00H ; STORE R2'S ROW VALUE
ROWSCAN:	RRC	A	; SERACHING WHICH ROW CHANGES 0->1
		JNC	MATRIX	; IF CARRY OCCURS -> BRANCH TO MATRIX
		INC	R6	; IF CARRY DOESN'T OCCURS -> MOVE NEXT ROW
		JMP	ROWSCAN	; BRANCH FOR SCANNING NEXT ROW

MATRIX:		MOV	A, R6	; PRESERVE ROW VALUE AT R6
		MOV	B, #05H	; 1ROW CONSISTS 5 COLUMNS
		MUL	AB	; CHANGE 2D-MAT TO 1D-MAT
		ADD	A, R4	; PRESERVE COLUMN VALUE AT R4
		CALL	INDEX	; SELECT KEY CODE
		POP	PSW	; BRING PSW TO STACK\
		RET		; RETURN TO ORIGINAL ROUTINE


;==========
; SUBROUTINE : SUBKEY
; INPUT : ACC
; OUTPUT : ACC
; FUNC : PULL DATA TO DATAOUT AND CHECK RESULT BY USING DATAIN
;==========
SUBKEY:		MOV	DPTR,#DATAOUT
		MOVX	@DPTR, A
		MOV	DPTR,#DATAIN
		MOVX	A,@DPTR
		RET


;===========
; SUBROUTINE : INDEX
; INPUT : ACC
; OUTPUT : ACC
; FUNC : DEFINE KEY CODE
;==========

INDEX	MOVC A, @A+PC	; A CAN GET 1~24 NUM.
	RET

KEYBASE:	DB	ST	; SW1, ST	1
		DB	INCR	; SW6, INCREASE	2
		DB	CD	; SW11, CD	3
		DB	REG	; SW15, REG	4
		DB	GO	; SW19, GO	5
		DB	0CH	; SW2, C	6
		DB	0DH	; SW7, D	7
		DB	0EH	; SW12, E	8
		DB	0FH	; SW16, F	9
		DB	COMMA	; SW20, COMMA(,)10
		DB	08H	; SW3, 8	11
		DB	09H	; SW8, 9	12
		DB	0AH	; SW13, A	13
		DB	0BH	; SW14, B	14
		DB	PERIOD	; SW21, PERIOD(.)15
		DB	04H	; SW4, 4	16
		DB	05H	; SW9, 5	17
		DB	06H	; SW14, 6	18
		DB	07H	; SW18, 7	19
		DB	RWKEY	; SW22, R/W	20
		DB	00H	; SW5, 0	21
		DB	01H	; SW10, 1	22
		DB	02H	; SW22, 2	23
		DB	03H	; SW23, 3	24
		DB	RST	; SW24, RST KEY	25

IF4:		CJNE	A,#04H, IF1	; IF INPUT DOESN'T EQUAL AS 4 -> JUMP TO IF1
		MOV	MYKEY, A	
		CALL	HEADER
		RET

IF1:		CJNE	A,#01H, IF6	; IF INPUT DOESN'T EQUAL AS 1 -> JUMP TO IF6
		MOV	MYKEY, A
		CALL	HEADER
		RET

IF6:		CJNE	A,#06H, IF9	; IF INPUT DOESN'T EQUAL AS 6 -> JUMP TO IF9
		MOV	MYKEY, A
		CALL	HEADER
		RET

IF9:		CJNE	A,#09H, NOTFOUND ; IF INPUT DOESN'T EQUAL AS 9 -> JUMP TO NOTFOUND
		MOV 	MYKEY, A
		CALL	HEADER
		RET

NOTFOUND:	RET

HEADER:		A, MYKEY

L_MOVE:		CJNE	A,#04H,R_MOVE

END