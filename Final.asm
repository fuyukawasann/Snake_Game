ORG	8000H
COLGREEN	EQU	0FFC5H
COLRED		EQU	0FFC6H
ROW		EQU	0FFC7H
SEGMENT		EQU	0FFC1H		;8BIT
DATAOUT		EQU	0FFF0H
DATAIN		EQU	0FFF1H
SNAKECOL	EQU	30H
SNAKEROW	EQU	31H
FEEDCOL		EQU	32H
FEEDROW		EQU	33H
SCORE		EQU	34H
TIMEVALUE	EQU	35H
SECOND		EQU	36H
LIFE		EQU	37H
PAUSE		EQU	38H

;R0 : FINDKEYCODE
;R1 : FINDKEYCODE
;R2 : FINDKEYCODE
;R3 :
;R4
;R5
;R6 :
;R7 : TL RANDOM NUMBER

;==========FUNCTION KEY
RWKEY	EQU	10H
COMMA	EQU	11H
PERIOD	EQU	12H
GO	EQU	13H
REG	EQU	14H
CD	EQU	15H
INCR	EQU	16H
ST	EQU	17H
RST	EQU	18H

;==========LCD VARIABLES
LCDWIR	EQU	0FFE0H
LCDWDR	EQU	0FFE1H
LCDRIR	EQU	0FFE2H
LCDRDR	EQU	0FFE3H

INST	EQU	20H
DATA	EQU	21H
LROW	EQU	22H; LCD ROW1,2
LCOL	EQU	23H; LCD COL0~
NUMFONT	EQU	24H; MESSAGE NUMBER
FDPL	EQU	25H
FDPH	EQU	26H

;=========LCD INSTRUCTIONS
CLEAR	EQU	01H
CUR_HOME	EQU	02H	;MOVE CURSOR HOME
ENTRY2	EQU	06H		;CURSOR DIRECION, ADDRESS+1,CURSOR RIGHT

DCB6	EQU	0EH		;CURSOR ON, BLINK OFF
FUN5	EQU	38H		

LINE_1	EQU	80H
LINE_2	EQU	0C0H

;============REGISTER SAVE
BPOR	EQU	2CH
BPOR2	EQU	2DH
BPOR3	EQU	2EH

;============KEY SAVE
VBUF	EQU	40H
CKOV	EQU	41H	; SET:GAMEOVER
BPOV	EQU	42H


;============DIRECT SAVE
DIRECT1	EQU	4DH

;INITIALIZING LCD
LCD_INIT:	MOV	INST,#FUN5
		CALL	INSTWR
		MOV	INST,#DCB6
		CALL	INSTWR
		MOV	INST,#CLEAR
		CALL	INSTWR
		MOV	INST,#ENTRY2
		CALL	INSTWR
		
		MOV	A,#00H
		MOV	DPTR,#0FFC1H
		MOVX	@DPTR,A
		MOV	DPTR,#0FFC2H
		MOVX	@DPTR,A
		MOV	DPTR,#0FFC3H
		MOVX	@DPTR,A		; 7SEGMENT INIT
		MOV	TMOD,#00000001B
		SETB	TCON.TR0	;TIMER ON -> 처음 입력으로부터 난수를 받는다

		MOV	R3,#2		;출력할 열의 초기값
		JMP	START

DEC_R3:		DEC	R3		;한 루프를 돌 때마다 출력할 열을 한칸 왼쪽으로 이동
		MOV	A,R3
		INC	A
		JZ	REFILL_R3	;R3=0일 경우, 다시 R3=20으로 돌아간다.

START:		MOV	A,R3		;출력할 열의 초기값
		MOV	R4,A		;R4레지스터는 DISFONT ROUTINE에서 전달인자로 쓰인다.
		MOV	LROW,#01H	
		MOV	LCOL,R4
		CALL	CUR_MOV		;1번째 행에 출력

		MOV	DPTR,#MESSAGE1	
		MOV	FDPL,DPL
		MOV	FDPH,DPH	;PRESS ANY KEY를 순서대로 출력하기 위해 DPTR을 적절한 주소를 가리키게 한다.
		MOV	NUMFONT,#0DH	;출력할 문자 개수 13개
		CALL	DISFONT		;DISFONT SUBROUTINE 설명 참조
		
		MOV	LROW,#02H
		MOV	LCOL,R4
		CALL	CUR_MOV		;2번째 행에 출력
	
		MOV	DPTR,#MESSAGE2	;TO START를 출력하기 위해 DPTR이 적절한 주소를 가리키게 한다.
		MOV	FDPL,DPL
		MOV	FDPH,DPH
		MOV	NUMFONT,#08H	;출력할 문자 개수 8개
		CALL	DISFONT
		CALL	DELAY		

		MOV	INST,#CLEAR
		CALL	INSTWR		; LCD 클리어

		CALL	FINDKEYCODE	; ACCUMULATOR에 KEY 값을 저장한다. 아무것도 입력하지 않은 경우 0을 저장한다.
	
		CJNE	A,#00H,GAME_START	;실제로 아무 키가 눌렸다면 A는 0을 갖지 않아 GAME_START로 점프한다. 
						;이 때 FINDKEYCODE에서 이미 난수를 구했으므로 이것으로 먹이 위치를 조정할 수 있다.
		JMP	DEC_R3			;눌리지 않았다면 A=0이라 이 INSTRUCTION에 빠지고 다시 루프한다.
REFILL_R3:	MOV	R3,#20		
		JMP	DEC_R3

GAME_START:
	MOV	SCORE,#00H
	CALL	BCD			;SCORE INIT
	MOV	SECOND,#0		;SECOND INIT
	MOV	TIMEVALUE,#14		;모드1로 타이머 인터럽트를 0000H에서 시작한다면 2^16=65536 CYCLE이 돌고, 이것의 14배가 917,504 CYCLE이므로, 
					;타이머 인터럽트가 14번 돌면 1초로 어림잡을 수 있다. (1초=921600 CYCLE)
	MOV	LIFE,#11111000B		;핀포트에 입력할 값
	CLR	TCON.TR0		
	MOV	IE,#10000011B		;INT0, 타이머인터럽트0 허용
	MOV	TH0,#00H
	MOV	TL0,#00H		;초기 난수를 구하기 위해 켜둔 타이머를 끄고 타이머 인터럽트를 본격적으로 세팅
	MOV	PAUSE,#0		;PAUSE여부를 알 수 있는 FLAG. 0에서 눌리면 1이 되고 게임 일시정지 할 것이다.

RESTART:				;벽에 부딪혀서 다시 게임이 시작될 때, 이 곳으로 점프한다.
	MOV	CKOV,#0			;벽에 부딪혔는지를 알 수 있는 FLAG. 1이면 해당 라운드를 종료하게 할 것이다. 
	MOV	A,#00000000B
	MOV	DPTR,#ROW
	MOVX	@DPTR,A
	MOV	DPTR,#COLGREEN
	MOVX	@DPTR,A
	MOV	DPTR,#COLRED
	MOVX	@DPTR,A		;DOT MATRIX INIT


	MOV	A,LIFE
	MOV	P1,A		;핀 포트 출력
	
	MOV	SNAKEROW,#00001000B
	MOV	SNAKECOL,#00001000B
	MOV	FEEDROW,#00000001B
	MOV	FEEDCOL,#00000001B
	CALL	RESETFEED		; SNAKE,FEED PLACE INIT
	MOV	DIRECT1,#01		; DIRECTION INIT
	SETB	TCON.TR0		; 타이머 시작
MAIN:
	CALL	DISPSNAKE		; 뱀의 위치를 DOT MATRIX에 표현
	CALL	DELAY
	CALL	DIRECT			; 1,4,6,9 키가 눌렸는지 확인하고 이에 맞추어 DIRECTION을 바꿔준다
	CALL	DISPFEED		; 먹이 위치를 DOT MATRIX에 표현
	MOV	A,PAUSE
	JNZ	WATING			; PAUSE=1인 경우, 무한 점프해서 풀리기까지 대기한다.
	MOV	A,CKOV			
	JNZ	GAME_OVER		; 뱀의 위치가 벽에 닿아서 CKOV = 1 이 됐는지 확인하고, 맞다면 GAME_OVER ROUTINE으로
	CALL	DELAY
	CALL	DIRECT
	JMP	MAIN			; 타이머 인터럽트가 14번 걸릴 때까지 계속해서 MAIN ROUTINE을 루프할 것이다.
WATING:	MOV	A,PAUSE
	JZ	MAIN
	JMP	WATING
GAME_OVER:
	CLR	TCON.TR0		
	MOV	A,LIFE
	SETB	C
	RRC	A
	MOV	LIFE,A			; 벽에 부딪혔다면, 타이머를 끄고 라이프를 1줄인다 (ROTATING으로 구현)
	CJNE	A,#11111111B,RESTART	; 모두 ROTATING 된 경우 게임이 완전 종료, 아래 INSTRUCTION으로 진행한다.
	
	MOV	R4,#00
	MOV	LROW,#01
	MOV	LCOL,R4
	CALL	CUR_MOV
	
	MOV	DPTR,#MESSAGE4
	MOV	FDPL,DPL
	MOV	FDPH,DPH		
	MOV	NUMFONT,#09H
	CALL	DISFONT			; LCD에 GAME OVER 출력
LOOP:	CALL	FINDKEYCODE		
	JZ	LOOP
	CALL	DELAY
	MOV	IE,#00000000B
	MOV	R3,#2
	MOV	SCORE,#00H
	CALL	BCD
	JMP	START			; 다음 KEY가 입력 될 때까지 기다렸다가 입력되면 다시 맨 처음으로 돌아간다.
	
;======SUBROUTINE:DIRECT
; OUTPUT: DIRECT에 눌린 키와 관련된 방향 정보 저장. 아무것도 눌리지 않은 경우 이전 상태에서 변하지 않는다.

DIRECT:	CALL	FINDKEYCODE
SEL4:	CJNE	A,#04H,SEL1
	MOV	DIRECT1,#10	; 왼쪽
	RET
SEL1:	CJNE	A,#01H,SEL6
	MOV	DIRECT1,#00	; 아래
	RET
SEL6:	CJNE	A,#06H,SEL9
	MOV	DIRECT1,#01	; 오른쪽
	RET
SEL9:	CJNE	A,#09H,NSEL
	MOV	DIRECT1,#11	; 위
NSEL:	RET

;=======SUBROUTINE MOVER
; INPUT : DIRECT1
; OUTPUT: 다음 루프에서의 SNAKE위치
; FUNCTION: DIRECT1에 저장된 정보를 불러와 각 정보에 해당하는 SNAKECOL, SNAKEROW 값의 이동을 통해 해당 방향으로의 전진을 구현. 
; 이 때 CARRY가 SET되는 경우, 이는 SNAKE의 위치가 벽을 통과했다는 뜻이므로 GAME_OVER BRANCH를 통해 CKOV=1로 SET해준다.
MOVER:	MOV	A,DIRECT1
	CLR	C
D_MOVE:	CJNE	A,#00,U_MOVE
	MOV	A,SNAKEROW
	RLC	A
	JC	GAME_SET
	MOV	SNAKEROW,A
	RET
U_MOVE:	CJNE	A,#11,L_MOVE
	MOV	A,SNAKEROW
	RRC	A
	JC	GAME_SET
	MOV	SNAKEROW,A
	RET
L_MOVE:	CJNE	A,#10,R_MOVE
	MOV	A,SNAKECOL
	RRC	A
	JC	GAME_SET
	MOV	SNAKECOL,A
	RET
R_MOVE:	MOV	A,SNAKECOL
	CLR	C
	RLC	A
	JC	GAME_SET
	MOV	SNAKECOL,A
	RET
GAME_SET:
	MOV	CKOV,#1
	RET
	

;======SUBROUTINE CUR_MOV
CUR_MOV:
	MOV	A,LROW
	CJNE	A,#01H,NEXT
	MOV	A,#LINE_1
	ADD	A,LCOL
	MOV	INST,A
	CALL	INSTWR
	JMP	RET_POINT
NEXT:	CJNE	A,#02H,RET_POINT
	MOV	A,#LINE_2
	ADD	A,LCOL
	MOV	INST,A
	CALL	INSTWR
RET_POINT:	RET

;=========SUBROUTINE DISFONT
;INPUT R4 - 초기 열 위치를 갖고 있다.
;	NUMFONT - 출력할 문자열 갯수
;FUNCTION - 초기 열 위치에 R5 OFFSET을 더하면서, 20이 넘는 순간 다시 0열로 돌아가서 나머지 문자열을 출력한다.
DISFONT:	MOV	R5,#00H
FLOOP3:	MOV	A,R4
	ADD	A,R5
	CJNE	A,#20,FLOOP
	MOV	LCOL,#00H
	CALL	CUR_MOV
FLOOP2:	MOV	DPL,FDPL
	MOV	DPH,FDPH
	MOV	A,R5
	MOVC	A,@A+DPTR
	MOV	DATA,A
	CALL	DATAWR
	INC	R5
	MOV	A,R5
	CJNE	A,NUMFONT,FLOOP2
	RET
FLOOP:	MOV	DPL,FDPL
	MOV	DPH,FDPH
	MOV	A,R5
	MOVC	A,@A+DPTR
	MOV	DATA,A

	CALL	DATAWR
	INC	R5
	MOV	A,R5
	CJNE	A,NUMFONT,FLOOP3
	RET

;==========
; SUBROUTINE : DISP_TIME
; INPUT : SECOND(PLAY TIME)
; OUTPUT : LCD DISPLAY
; FUNC : DISPLAY PLAYING TIME AT LCD DISPLAY
;==========
DISP_TIME:	;CLEAR LCD
		MOV	LROW, #02H
		MOV	LCOL, #07H
		CALL	CUR_MOV
		MOV	DPTR, #MSGCLR
		MOV	FDPL, DPL
		MOV	FDPH, DPH
		CALL	CLRDISP
		
		;DISPLAY TIME
		MOV	LROW, #02H
		MOV	LCOL, #07H
		CALL	CUR_MOV
		MOV	DPTR, #NUM
		MOV	FDPL, DPL
		MOV	FDPH, DPH
		CALL	TIMEDISP

		;CLEAR ONCE
		MOV	DPTR, #MSGCLR	; 이상하게 두 번 출력되는 오류로 인한 추가
		MOV	FDPL, DPL
		MOV	FDPH, DPH
		CALL	CLRDISP

TIMEDISP:	PUSH	A
		MOV	A, SECOND
		MOV	B, #1000
		DIV	AB
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR
		
		MOV	A, B
		MOV	B, #100
		DIV	AB
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, B
		MOV	B, #10
		DIV	AB
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR
		
		MOV	A, B
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		POP	A
		RET

CLRDISP:	PUSH	A
		
		MOV	A, #00
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR
	
		MOV	A, #01
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, #02
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, #03
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, #00
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR
	
		MOV	A, #01
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, #02
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR

		MOV	A, #03
		MOV	DPL, FDPL
		MOV	DPH, FDPH
		MOVC	A, @A+DPTR
		MOV	DATA, A
		CALL	DATAWR
		
		POP	A
		RET
		

;==========SUBROUTINE DATAWR
DATAWR:	CALL	INSTRD
	MOV	DPTR,#LCDWDR
	MOV	A,DATA
	MOVX	@DPTR,A
	RET
;=-========SUBROUTINE INSTWR
INSTWR:	CALL	INSTRD
	MOV	DPTR,#LCDWIR
	MOV	A,INST
	MOVX	@DPTR,A
	RET
;==========SUBROUTINE INSTRD
INSTRD:	MOV	DPTR,#LCDRIR
	MOVX	A,@DPTR
	JB	ACC.7,INSTRD
	RET
;=========DEFINE MESSAGE
MESSAGE1:
	DB	'P','r','e','s','s'
	DB	' ','A','n','y',' '
	DB	'K','e','y'
MESSAGE2:
	DB	't','o',' ','S','t'
	DB	'a','r','t'
MESSAGE3:
	DB	'P',' ','A',' ','U'
	DB	' ','S',' ','E'
MESSAGE4:
	DB	'G','a','m','e',' '
	DB	'O','v','e','r'

NUM:	DB	'0','1','2','3','4'
	DB	'5','6','7','8','9'

MSGCLR:	DB	' ',' ',' ',' ',' '


;===========SUBROUTINE FINDKEYCODE
; INPUT 키패드 입력
; OUTPUT ACCUMULATOR에 입력된 KEY의 DB를 저장한다. 아무것도 눌리지 않은 경우 A에 0을 저장한다.
FINDKEYCODE:
	MOV	R1,#00H
	MOV	A,#11101111B
	SETB	C
COLSCAN:
	MOV	R0,A
	INC	R1
	CALL	SUBKEY
	ANL	A,#00011111B
	XRL	A,#00011111B
	JNZ	RSCAN
	MOV	A,R0
	SETB	C
	RRC	A
	JNC	RET_0		;입력이 없으면 A에 0 저장
STARTING:	JMP	COLSCAN
RSCAN:	MOV	R2,#00H
	MOV	R7,TL0		;어떤 KEY가 입력된 경우, 이 때의 타이머 값을 R7에 저장함으로써 난수구현에 사용한다.
ROWSCAN:
	RRC	A
	JC	MATRIX
	INC	R2
	JMP	ROWSCAN

RET_0:	MOV	A,#0
	RET

MATRIX:	MOV	A,R2
	MOV	B,#05H
	MUL	AB
	ADD	A,R1
	CALL	INDEX
	RET			;A에 KEY에 해당하는 값이 저장돼있다.
;==========SUBROUTINE SUBKEY
SUBKEY:	MOV	DPTR,#DATAOUT
	MOVX	@DPTR,A
	MOV	DPTR,#DATAIN
	MOVX	A,@DPTR
	RET
;==========SUBROUTINE INDEX
INDEX:	MOVC	A,@A+PC
	RET
KEYBASE:
	DB	ST
	DB	INCR
	DB	CD
	DB	REG
	DB	GO
	DB	0CH
	DB	0DH
	DB	0EH
	DB	0FH
	DB	COMMA
	DB	08H
	DB	09H
	DB	0AH
	DB	0BH
	DB	PERIOD
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	RWKEY
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	RST

;===========SUBROUTINE SCOREADD
; FEED와 SNAKE의 위치가 일치할때 이 SUBROUTINE 동작
; OUTPUT - SCORE가 1 증가, SEGMENT에 출력
SCOREADD:
	INC	SCORE
	MOV	A,SCORE
	CJNE	A,#64H,BCD	; SCORE가 100인 경우, 다시 00을 출력하게 한다.
	MOV	SCORE,#00H
	JMP	BCD
	
;============SUBROUTINE CHECKPLACE
; FEED와 SNAKE 위치를 확인하고, 일치하는 경우 SCOREADD를 통해 SCORE 증가 후 SEGMENT 출력과, 기존에 갖고 있던 R7을 이용한 먹이 위치 랜덤 구현을 동작
CHECKPLACE:
	MOV	A,CKOV
	JNZ	GOAHEAD		; CKOV=1인 경우, GMEOVER이므로 바로 RETURN하게 한다.
	MOV	A,SNAKECOL
	CJNE	A,FEEDCOL,GOAHEAD
	MOV	A,SNAKEROW
	CJNE	A,FEEDROW,GOAHEAD
	CALL	SCOREADD	; GET FEED -> SCORE+1
	CALL	RESETFEED	; NEW FEEDCOL,FEEDROW SET
GOAHEAD: RET

;===========SUBROUTINE DISPSNAKE,DISPFEED
; INPUT - SNAKE COL,ROW 와 FEED COL,ROW
; FUNCTION - 위치 정보를 이용해 DOT MATRIX에 출력
DISPSNAKE:
	MOV	DPTR,#ROW
	MOV	A,SNAKEROW
	MOVX	@DPTR,A

	MOV	DPTR,#COLGREEN
	MOV	A,SNAKECOL
	MOVX	@DPTR,A
	
	MOV	DPTR,#COLRED
	MOV	A,#00000000B
	MOVX	@DPTR,A
	RET
DISPFEED:
	MOV	DPTR,#ROW
	MOV	A,FEEDROW
	MOVX	@DPTR,A

	MOV	DPTR,#COLRED
	MOV	A,FEEDCOL
	MOVX	@DPTR,A

	MOV	DPTR,#COLGREEN
	MOV	A,#00000000B
	MOVX	@DPTR,A
	RET


;=========SUBROUTINE BCD
; INPUT - SCORE
; FUNCTION - 입력된 SCORE 값을 BCD 변환 후 SEGMENT에 출력
BCD:	MOV	BPOR,R0
	MOV	A,SCORE
	MOV	B,#10
	DIV	AB
	SWAP	A
	MOV	R0,B
	ORL	A,R0
	MOV	DPTR,#SEGMENT
	MOVX	@DPTR,A
	MOV	R0,BPOR
	RET

;=============SUBROUTINE RESETFEED
; INPUT - R7 (RANDOM NUMBER)
; OUTPUT - NEW FEED PLACE
; FUNCTION - TL0에서 얻은 값 * 3을 통해 난수를 얻고, 이 값을 16에 대한 몫, 나머지 각 정보를 이용해 FEEDROW, FEEDCOL의 위치를 갱신한다.
RESETFEED:
	MOV	A,R7
	MOV	B,#3
	MUL	AB
	MOV	B,#16	
	DIV	AB		; A에 몫, B에 나머지 저장 (0~15의 값)
	MOV	R3,A
	MOV	A,FEEDCOL
COLROT:	RL	A
	DJNZ	R3,COLROT	
	MOV	FEEDCOL,A	; 0~15의 무작위 수 만큼 FEEDCOL을 ROTATING한 후 저장
	MOV	R3,B
	MOV	A,FEEDROW
ROWROT:	RL	A
	DJNZ	R3,ROWROT
	MOV	FEEDROW,A	; 0~15의 무작위 수 만큼 FEEDROW를 ROTATING한 후 저장
	RET
	
DELAY:	MOV	BPOR,R5
	MOV	BPOR2,R6
	MOV	R5,#0FFH
DELAY1:	MOV	R6,#0FFH
DELAY2:	DJNZ	R6,DELAY2
	DJNZ	R5,DELAY1
	MOV	R6,BPOR2
	MOV	R5,BPOR
	RET

;==========
INCRESEC:	PUSH	A
		MOV	A, SECOND
		INC	A
		MOV	SECOND, A
		POP	A
		RET


;======INTERRUPT SERVICE
; INPUT - TIMEVALUE
; FUNCTION - TIMEVALUE값이 ISR에 진입할때마다 줄어듦으로써, 14회 진입한 경우, 즉 약 1초가 지났을 때 SECOND를 올리고, MOVER, CHECKPLACE ROUTINE에 진입한다.
SERVICE:
	CLR	TCON.TR0
	PUSH	A
	DJNZ	TIMEVALUE,SERRET
	MOV	TIMEVALUE,#14
	CALL	INCRESEC
	CALL	DISP_TIME
	CALL	MOVER
	CALL	CHECKPLACE
SERRET:	MOV	TH0,#00H
	MOV	TL0,#00H
	POP	A
	SETB	TCON.TR0
	RETI

;=======INTERRUPT SERVICE2
; INPUT - PAUSE FLAG
; FUNCTION - 게임을 멈추고 LCD에 PAUSE 표시. 다시 누르면 게임 재개
SERVICE2:
	CLR	TCON.TR0
	PUSH	A
	MOV	A,PAUSE
	JZ	PAUSING
	
	MOV	PAUSE,#0	
	MOV	INST,#CLEAR
	CALL	INSTWR
	POP	A
	SETB	TCON.TR0
	RETI			; PAUSE=1이어서 게임이 중단되었던 경우에 다시 입력된 경우. LCD를 초기화 해주고 타이머를 다시 키면서 인터럽트 복귀한다.
PAUSING:
	MOV	PAUSE,#1
	MOV	INST,#CLEAR
	CALL	INSTWR
	MOV	R4,A		
	MOV	LROW,#01H	
	MOV	LCOL,R4
	CALL	CUR_MOV		;1번째 행에 출력

	MOV	DPTR,#MESSAGE3	
	MOV	FDPL,DPL
	MOV	FDPH,DPH	;PRESS ANY KEY를 순서대로 출력하기 위해 DPTR을 적절한 주소를 가리키게 한다.
	MOV	NUMFONT,#09H	;출력할 문자 개수 9개
	CALL	DISFONT	
	POP	A
	RETI

ORG	0003H
JMP	SERVICE2

ORG	000BH
JMP	SERVICE
END